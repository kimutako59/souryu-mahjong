<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ€„ é€†è»¢æ¡ä»¶ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã€€ç‚¹å·®ï¼†ãƒˆãƒ¼ã‚¿ãƒ«æ¡ä»¶è¨ˆç®—æ©Ÿ</title>

    <style>
        body {
            font-family: "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            background: linear-gradient(135deg, #f5f7ff, #f3fbf5);
            color: #333;
            margin: 0;
            padding: 10px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        header {
            background: linear-gradient(120deg, #4f86c6, #7ed6a8);
            color: white;
            padding: 15px;
            text-align: center;
        }
        header h1 {
            margin: 0;
            font-size: 1.2rem;
        }

        .section {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }

        .section-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .section-title-left {
            display: flex;
            align-items: center;
        }
        .section-title-left::before {
            content: '';
            display: inline-block;
            width: 4px;
            height: 1em;
            background: #e74c3c;
            margin-right: 8px;
        }

        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            font-size: 0.85rem;
        }
        .input-row label {
            flex: 1;
        }
        .input-row input,
        .input-row select {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
            text-align: right;
            box-sizing: border-box;
        }
        .input-row span.unit {
            margin-left: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
        }

        .player-row {
            display: flex;
            align-items: center;
            background: #f9f9ff;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 6px;
        }
        .player-row.active {
            background: #e1fbef;
            border: 1px solid #2ecc71;
        }
        .radio-col {
            width: 40px;
            text-align: center;
        }
        .name-col {
            width: 60px;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
        }
        .score-col {
            flex: 1;
        }

        .score-input {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .score-buttons-row {
            display: flex;
            gap: 4px;
            margin-bottom: 2px;
        }
        .score-buttons-row button {
            flex: 1 1 0;
            min-width: 0;
            padding: 4px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #ecf3ff;
            cursor: pointer;
            font-size: 0.7rem;
        }
        .score-buttons-row button:hover {
            background: #d4e4ff;
        }
        .score-input input {
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95rem;
            text-align: right;
            max-width: 110px;
            align-self: flex-end;
        }

        button.calc-btn {
            width: 100%;
            padding: 15px;
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
        }
        button.calc-btn:hover {
            background: #c0392b;
        }

        .sub-btn {
            width: 100%;
            padding: 14px;
            background: #bdc3c7;
            color: #2c3e50;
            border: none;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            border-radius: 6px;
        }
        .sub-btn:hover {
            background: #a0acb3;
        }

        .btn-row {
            display: flex;
            gap: 8px;
            padding: 0 15px 15px;
        }

        .result-area {
            padding: 15px;
            background: #f4f7fb;
            min-height: 100px;
        }

        .target-card {
            background: white;
            margin-bottom: 15px;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-left: 5px solid #3498db;
            transition: 0.2s;
        }
        .target-card-easy {
            border-left-color: #e74c3c;
            box-shadow: 0 0 8px rgba(231, 76, 60, 0.35);
        }
        .target-card-hard {
            border-left-color: #7f8c8d;
            opacity: 0.75;
        }

        .chance-badge {
            background: #ffe6e0;
            padding: 2px 6px;
            border-radius: 10px;
            color: #c0392b;
            font-size: 0.7rem;
            font-weight: bold;
            margin-right: 4px;
        }

        .target-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
            margin-bottom: 6px;
            color: #2980b9;
        }
        .target-header-right {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 0.8rem;
        }

        .card-toggle-btn {
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid #bdc3c7;
            background: #ecf0f1;
            font-size: 0.7rem;
            cursor: pointer;
        }
        .card-toggle-btn:hover {
            background: #d0d7dd;
        }

        .cond-block {
            padding-top: 6px;
            margin-top: 6px;
            border-top: 1px dashed #e0e4ea;
        }

        .condition-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
            font-size: 0.9rem;
        }
        .condition-label {
            color: #555;
        }
        .condition-main-label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 0.95rem;
            padding: 2px 8px;
            background: #eef4ff;
            border-radius: 999px;
        }
        .condition-label-strong {
            font-weight: bold;
            color: #34495e;
            font-size: 0.95rem;
        }
        .condition-val {
            font-weight: bold;
            color: #e74c3c;
        }

        .condition-detail {
            font-size: 0.75rem;
            color: #555;
            margin-bottom: 6px;
        }

        .mini-note {
            font-size: 0.75rem;
            color: #7f8c8d;
            margin-top: 6px;
        }

        .two-col {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .two-col .input-row {
            flex: 1 1 48%;
        }

        .status-summary {
            padding: 8px 12px;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #dde4ee;
            margin: 0 15px 10px;
            font-size: 0.8rem;
            color: #34495e;
        }
        .status-line {
            margin-bottom: 2px;
        }
        .status-ok {
            color: #27ae60;
        }
        .status-warn {
            color: #e67e22;
        }
        .status-bad {
            color: #c0392b;
        }

        #customResult {
            margin-top: 6px;
            font-size: 0.8rem;
            padding: 6px 8px;
            background: #f9fbff;
            border-radius: 4px;
            border: 1px solid #dde4f0;
        }

        .view-mode-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 15px 10px;
            font-size: 0.85rem;
            color: #34495e;
        }
        .view-mode-row label {
            white-space: nowrap;
        }
        .view-mode-row select {
            padding: 4px 8px;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
        }

        @media (max-width: 600px) {
            .two-col .input-row {
                flex: 1 1 100%;
            }
            .btn-row {
                flex-direction: column;
            }
            .view-mode-row {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>

<body>
<div class="container">
    <header>
        <h1>ğŸ€„ é€†è»¢æ¡ä»¶ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã€€ç‚¹å·®ï¼†ãƒˆãƒ¼ã‚¿ãƒ«æ¡ä»¶è¨ˆç®—æ©Ÿ</h1>
    </header>

    <!-- å ´æ³ -->
    <div class="section">
        <div class="section-title">
            <div class="section-title-left">å ´æ³è¨­å®š</div>
        </div>
        <div class="two-col">
            <div class="input-row">
                <label>ä¾›è¨— (ãƒªãƒ¼ãƒæ£’)</label>
                <input type="number" id="kyotaku" value="0" min="0">
                <span class="unit">æœ¬</span>
            </div>
            <div class="input-row">
                <label>æœ¬å ´ (ç©ã¿æ£’)</label>
                <input type="number" id="honba" value="0" min="0">
                <span class="unit">æœ¬å ´</span>
            </div>
        </div>
    </div>

    <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç‚¹æ•° -->
    <div class="section">
        <div class="section-title">
            <div class="section-title-left">ç‚¹æ•°å…¥åŠ›ï¼ˆè‡ªåˆ†ã®å¸­ã«ãƒã‚§ãƒƒã‚¯ãƒ»100ç‚¹å˜ä½èª¿æ•´å¯ï¼‰</div>
        </div>

        <div class="player-row" id="row-east">
            <div class="radio-col">
                <input type="radio" name="mySeat" value="0" onclick="highlightMe(0)">
            </div>
            <div class="name-col">æ±å®¶</div>
            <div class="score-col">
                <div class="score-input">
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(0,-100)">-100</button>
                        <button type="button" onclick="adjustScore(0,-1000)">-1000</button>
                        <button type="button" onclick="adjustScore(0,-10000)">-10000</button>
                    </div>
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(0,100)">+100</button>
                        <button type="button" onclick="adjustScore(0,1000)">+1000</button>
                        <button type="button" onclick="adjustScore(0,10000)">+10000</button>
                    </div>
                    <input type="number" id="score0" value="25000" step="100">
                </div>
            </div>
        </div>

        <div class="player-row" id="row-south">
            <div class="radio-col">
                <input type="radio" name="mySeat" value="1" onclick="highlightMe(1)" checked>
            </div>
            <div class="name-col">å—å®¶</div>
            <div class="score-col">
                <div class="score-input">
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(1,-100)">-100</button>
                        <button type="button" onclick="adjustScore(1,-1000)">-1000</button>
                        <button type="button" onclick="adjustScore(1,-10000)">-10000</button>
                    </div>
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(1,100)">+100</button>
                        <button type="button" onclick="adjustScore(1,1000)">+1000</button>
                        <button type="button" onclick="adjustScore(1,10000)">+10000</button>
                    </div>
                    <input type="number" id="score1" value="25000" step="100">
                </div>
            </div>
        </div>

        <div class="player-row" id="row-west">
            <div class="radio-col">
                <input type="radio" name="mySeat" value="2" onclick="highlightMe(2)">
            </div>
            <div class="name-col">è¥¿å®¶</div>
            <div class="score-col">
                <div class="score-input">
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(2,-100)">-100</button>
                        <button type="button" onclick="adjustScore(2,-1000)">-1000</button>
                        <button type="button" onclick="adjustScore(2,-10000)">-10000</button>
                    </div>
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(2,100)">+100</button>
                        <button type="button" onclick="adjustScore(2,1000)">+1000</button>
                        <button type="button" onclick="adjustScore(2,10000)">+10000</button>
                    </div>
                    <input type="number" id="score2" value="25000" step="100">
                </div>
            </div>
        </div>

        <div class="player-row" id="row-north">
            <div class="radio-col">
                <input type="radio" name="mySeat" value="3" onclick="highlightMe(3)">
            </div>
            <div class="name-col">åŒ—å®¶</div>
            <div class="score-col">
                <div class="score-input">
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(3,-100)">-100</button>
                        <button type="button" onclick="adjustScore(3,-1000)">-1000</button>
                        <button type="button" onclick="adjustScore(3,-10000)">-10000</button>
                    </div>
                    <div class="score-buttons-row">
                        <button type="button" onclick="adjustScore(3,100)">+100</button>
                        <button type="button" onclick="adjustScore(3,1000)">+1000</button>
                        <button type="button" onclick="adjustScore(3,10000)">+10000</button>
                    </div>
                    <input type="number" id="score3" value="25000" step="100">
                </div>
            </div>
        </div>
        <div class="mini-note">
            â€» æ±å®¶ã‚’è¦ªã¨ã—ã¦è¨ˆç®—ã—ã¾ã™ã€‚è‡ªåˆ†ã®å¸­ã«ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã§ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚
        </div>
    </div>

    <!-- ã‚¦ãƒãƒ»ã‚ªã‚«ï¼†ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆ -->
    <div class="section">
        <div class="section-title">
            <div class="section-title-left">ã‚¦ãƒãƒ»ã‚ªã‚«ï¼†ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆè¨­å®š</div>
            <button id="umaToggleBtn" class="card-toggle-btn" type="button" onclick="toggleUmaSection()">è¨­å®šã‚’éš ã™</button>
        </div>

        <div id="umaSectionBody">
            <div class="two-col">
                <div class="input-row">
                    <label>è¿”ã—ç‚¹</label>
                    <input type="number" id="returnPoint" value="30000" step="1000">
                    <span class="unit">ç‚¹</span>
                </div>
                <div class="input-row">
                    <label>ã‚ªã‚«ï¼ˆ1ä½ã®ã¿ï¼‰</label>
                    <input type="number" id="oka" value="20" step="1">
                    <span class="unit">pt</span>
                </div>
            </div>

            <div class="input-row">
                <label>ã‚¦ãƒï¼ˆ1ã€œ4ä½ï¼‰</label>
                <input type="number" id="uma0" value="10" step="0.5" style="max-width:70px;">
                <input type="number" id="uma1" value="5" step="0.5" style="max-width:70px;">
                <input type="number" id="uma2" value="-5" step="0.5" style="max-width:70px;">
                <input type="number" id="uma3" value="-10" step="0.5" style="max-width:70px;">
                <span class="unit">pt</span>
            </div>
            <div class="mini-note">
                â€» 1åŠè˜ã®æˆç¸¾ = (æœ€çµ‚æŒã¡ç‚¹ âˆ’ è¿”ã—ç‚¹) Ã· 1000 ï¼‹ ã‚¦ãƒ ï¼‹ï¼ˆ1ä½ãªã‚‰ã‚ªã‚«ï¼‰ã¨ã—ã¦è¨ˆç®—ã—ã¾ã™ã€‚<br>
                ã€€ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆã¯ç¾åœ¨å€¤ï¼‹ã“ã®åŠè˜ã®æˆç¸¾ã§è¡¨ç¤ºã—ã¾ã™ã€‚
            </div>
        </div>

        <!-- ç¾åœ¨ã®ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆ -->
        <div style="margin-top:10px;">
            <div class="section-title" style="margin-bottom:5px; padding:0;">
                <div class="section-title-left" style="margin-bottom:0;">ç¾åœ¨ã®ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆ</div>
            </div>
            <div class="two-col">
                <div class="input-row">
                    <label>æ±å®¶</label>
                    <input type="number" id="total0" value="0.0" step="0.1">
                    <span class="unit">pt</span>
                </div>
                <div class="input-row">
                    <label>å—å®¶</label>
                    <input type="number" id="total1" value="0.0" step="0.1">
                    <span class="unit">pt</span>
                </div>
            </div>
            <div class="two-col">
                <div class="input-row">
                    <label>è¥¿å®¶</label>
                    <input type="number" id="total2" value="0.0" step="0.1">
                    <span class="unit">pt</span>
                </div>
                <div class="input-row">
                    <label>åŒ—å®¶</label>
                    <input type="number" id="total3" value="0.0" step="0.1">
                    <span class="unit">pt</span>
                </div>
            </div>
        </div>
    </div>

    <!-- ç‰¹å®šã®æ‰‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæŠ˜ã‚ŠãŸãŸã¿ï¼‰ -->
    <div class="section">
        <div class="section-title">
            <div class="section-title-left">ç‰¹å®šã®æ‰‹ã§ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</div>
            <button id="simToggleBtn" class="card-toggle-btn" type="button" onclick="toggleSimSection()">è¨­å®šã‚’è¡¨ç¤º</button>
        </div>
        <div id="simSectionBody" style="display:none;">
            <div class="two-col">
                <div class="input-row">
                    <label>ç¿»æ•°</label>
                    <input type="number" id="simHan" value="3" min="1" max="13">
                    <span class="unit">ç¿»</span>
                </div>
                <div class="input-row">
                    <label>ç¬¦</label>
                    <input type="number" id="simFu" value="40" step="10">
                    <span class="unit">ç¬¦</span>
                </div>
            </div>
            <div class="input-row">
                <label>ã‚¢ã‚¬ãƒªå½¢</label>
                <select id="simWinType" onchange="updateSimWinType()">
                    <option value="ron">ãƒ­ãƒ³</option>
                    <option value="tsumo">ãƒ„ãƒ¢</option>
                </select>
            </div>
            <div class="input-row" id="simRonTargetRow">
                <label>ãƒ­ãƒ³ç›¸æ‰‹ï¼ˆä»®å®šï¼‰</label>
                <select id="simRonTarget">
                    <option value="0">æ±å®¶</option>
                    <option value="1">å—å®¶</option>
                    <option value="2">è¥¿å®¶</option>
                    <option value="3">åŒ—å®¶</option>
                </select>
            </div>
            <div class="mini-note">
                â€» ç¾åœ¨ã®å ´æ³ãƒ»æŒã¡ç‚¹ãƒ»ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆãƒ»ã‚¦ãƒã‚ªã‚«ã‚’å‰æã«ã€æŒ‡å®šã—ãŸç¿»ãƒ»ç¬¦ãƒ»ã‚¢ã‚¬ãƒªå½¢ã§å±€ãŒçµ‚ã‚ã£ãŸå ´åˆã®åæ”¯ã¨ãƒˆãƒ¼ã‚¿ãƒ«ã‚’è¨ˆç®—ã—ã¾ã™ã€‚<br>
                ã€€ï¼ˆè‡ªåˆ†ã®å¸­ã¯ä¸Šã®ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã®è¨­å®šã‚’ä½¿ã„ã¾ã™ï¼‰
            </div>
            <button class="sub-btn" type="button" onclick="simulateCustomHand()">ã“ã®æ‰‹ã§ã©ã†ãªã‚‹ã‹è¨ˆç®—</button>
            <div id="customResult" style="display:none;"></div>
        </div>
    </div>

    <!-- çŠ¶æ³ã‚µãƒãƒªãƒ¼ -->
    <div id="statusSummary" class="status-summary">
        ï¼ˆç¾åœ¨ã®é †ä½ã‚µãƒãƒªãƒ¼ã¯ã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ï¼‰
    </div>

    <!-- è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ -->
    <div class="view-mode-row">
        <label for="viewMode">è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ï¼š</label>
        <select id="viewMode">
            <option value="attack">æ‰“å€’æ¡ä»¶ï¼ˆã¾ãã‚‹å´ï¼‰</option>
            <option value="defense">ãƒ©ã‚¹å›é¿ãƒ»é †ä½è½ã¡ï¼ˆã‚„ã‚‰ã‚Œã‚‹å´ï¼‰</option>
        </select>
    </div>

    <!-- ãƒœã‚¿ãƒ³è¡Œ -->
    <div class="btn-row">
        <button class="sub-btn" type="button" onclick="randomFill()">ãƒ©ãƒ³ãƒ€ãƒ å…¥åŠ›</button>
        <button class="calc-btn" type="button" onclick="calculate()">è¨ˆç®—å®Ÿè¡Œ</button>
    </div>

    <div class="result-area" id="resultArea">
        <div style="text-align:center; color:#7f8c8d; padding:20px;">
            ç‚¹æ•°ã¨ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆã‚’å…¥åŠ›ã—ã¦ã€Œè¨ˆç®—å®Ÿè¡Œã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚
        </div>
    </div>
</div>

<script>
    const winds = ["æ±å®¶", "å—å®¶", "è¥¿å®¶", "åŒ—å®¶"];

    const candidateHands = [
        { han: 1, fu: 30 },
        { han: 1, fu: 40 },
        { han: 2, fu: 20 },
        { han: 2, fu: 25 },
        { han: 2, fu: 30 },
        { han: 2, fu: 40 },
        { han: 2, fu: 50 },
        { han: 3, fu: 25 },
        { han: 3, fu: 30 },
        { han: 3, fu: 40 },
        { han: 3, fu: 50 },
        { han: 4, fu: 30 },
        { han: 4, fu: 40 },
        { han: 4, fu: 50 },
        { han: 5, fu: 30 },
        { han: 6, fu: 30 },
        { han: 7, fu: 30 },
        { han: 8, fu: 30 },
        { han: 11, fu: 30 },
        { han: 13, fu: 30 }
    ];

    let cardCounter = 0;

    function roundUp100(x) {
        return Math.ceil(x / 100) * 100;
    }

    function scoreHandDealer(han, fu) {
        let limitName = null;
        if (han >= 13)       limitName = "å½¹æº€";
        else if (han >= 11)  limitName = "ä¸‰å€æº€";
        else if (han >= 8)   limitName = "å€æº€";
        else if (han >= 6)   limitName = "è·³æº€";
        else if (han === 5 || (han === 4 && fu >= 40) || (han === 3 && fu >= 70)) {
            limitName = "æº€è²«";
        }

        let ron, tsumoEach;
        if (limitName) {
            if      (limitName === "æº€è²«")   { ron = 12000; tsumoEach = 4000; }
            else if (limitName === "è·³æº€")   { ron = 18000; tsumoEach = 6000; }
            else if (limitName === "å€æº€")   { ron = 24000; tsumoEach = 8000; }
            else if (limitName === "ä¸‰å€æº€") { ron = 36000; tsumoEach = 12000; }
            else if (limitName === "å½¹æº€")   { ron = 48000; tsumoEach = 16000; }
        } else {
            const base = fu * Math.pow(2, han + 2);
            ron = roundUp100(base * 6);
            tsumoEach = roundUp100(base * 2);
        }

        const label = limitName
            ? `${limitName}ï¼ˆ${han}ç¿»ä»¥ä¸Šï¼‰`
            : `${fu}ç¬¦${han}ç¿»`;

        return { han, fu, ron, tsumoEach, label, limitName };
    }

    function scoreHandChild(han, fu) {
        let limitName = null;
        if (han >= 13)       limitName = "å½¹æº€";
        else if (han >= 11)  limitName = "ä¸‰å€æº€";
        else if (han >= 8)   limitName = "å€æº€";
        else if (han >= 6)   limitName = "è·³æº€";
        else if (han === 5 || (han === 4 && fu >= 40) || (han === 3 && fu >= 70)) {
            limitName = "æº€è²«";
        }

        let ron, tsumoFromParent, tsumoFromChild;
        if (limitName) {
            if      (limitName === "æº€è²«") {
                ron = 8000;
                tsumoFromParent = 4000;
                tsumoFromChild  = 2000;
            } else if (limitName === "è·³æº€") {
                ron = 12000;
                tsumoFromParent = 6000;
                tsumoFromChild  = 3000;
            } else if (limitName === "å€æº€") {
                ron = 16000;
                tsumoFromParent = 8000;
                tsumoFromChild  = 4000;
            } else if (limitName === "ä¸‰å€æº€") {
                ron = 24000;
                tsumoFromParent = 12000;
                tsumoFromChild  = 6000;
            } else if (limitName === "å½¹æº€") {
                ron = 32000;
                tsumoFromParent = 16000;
                tsumoFromChild  = 8000;
            }
        } else {
            const base = fu * Math.pow(2, han + 2);
            ron = roundUp100(base * 4);
            tsumoFromParent = roundUp100(base * 2);
            tsumoFromChild  = roundUp100(base);
        }

        const label = limitName
            ? `${limitName}ï¼ˆ${han}ç¿»ä»¥ä¸Šï¼‰`
            : `${fu}ç¬¦${han}ç¿»`;

        return { han, fu, ron, tsumoFromParent, tsumoFromChild, label, limitName };
    }

    function scoreHand(han, fu, isParent) {
        if (isParent) {
            const d = scoreHandDealer(han, fu);
            return {
                han,
                fu,
                isParent: true,
                ron: d.ron,
                label: d.label,
                limitName: d.limitName,
                tsumoType: "dealer",
                tsumoEach: d.tsumoEach
            };
        } else {
            const c = scoreHandChild(han, fu);
            return {
                han,
                fu,
                isParent: false,
                ron: c.ron,
                label: c.label,
                limitName: c.limitName,
                tsumoType: "child",
                tsumoFromParent: c.tsumoFromParent,
                tsumoFromChild: c.tsumoFromChild
            };
        }
    }

    function highlightMe(index) {
        document.querySelectorAll('.player-row').forEach(row => row.classList.remove('active'));
        document.querySelectorAll('.player-row')[index].classList.add('active');
        updateStatusSummary();
    }
    highlightMe(1);

    function adjustScore(seat, delta) {
        const el = document.getElementById('score' + seat);
        const val = parseInt(el.value, 10) || 0;
        el.value = val + delta;
        updateStatusSummary();
    }

    function toggleUmaSection() {
        const body = document.getElementById('umaSectionBody');
        const btn  = document.getElementById('umaToggleBtn');
        if (body.style.display === 'none') {
            body.style.display = 'block';
            btn.textContent = 'è¨­å®šã‚’éš ã™';
        } else {
            body.style.display = 'none';
            btn.textContent = 'è¨­å®šã‚’è¡¨ç¤º';
        }
    }

    function toggleSimSection() {
        const body = document.getElementById('simSectionBody');
        const btn  = document.getElementById('simToggleBtn');
        if (body.style.display === 'none') {
            body.style.display = 'block';
            btn.textContent = 'è¨­å®šã‚’éš ã™';
        } else {
            body.style.display = 'none';
            btn.textContent = 'è¨­å®šã‚’è¡¨ç¤º';
        }
    }

    function getMySeat() {
        const radios = document.getElementsByName('mySeat');
        for (let i = 0; i < radios.length; i++) {
            if (radios[i].checked) return i;
        }
        return 0;
    }

    function randomFill() {
        document.getElementById('kyotaku').value = Math.floor(Math.random() * 4);
        document.getElementById('honba').value   = Math.floor(Math.random() * 6);

        const kyotaku = parseInt(document.getElementById('kyotaku').value, 10) || 0;

        const minEach = 1000;
        const totalPoints = 100000 - kyotaku * 1000;
        const remaining = totalPoints - 4 * minEach;
        const chips = remaining / 100;

        let rnd = [Math.random(), Math.random(), Math.random(), Math.random()];
        let sumRnd = rnd.reduce((a, b) => a + b, 0);
        let extraChips = [];
        let chipSum = 0;
        for (let i = 0; i < 4; i++) {
            const c = Math.floor(chips * rnd[i] / sumRnd);
            extraChips[i] = c;
            chipSum += c;
        }
        let rem = chips - chipSum;
        let idx = 0;
        while (rem > 0) {
            extraChips[idx % 4]++;
            idx++;
            rem--;
        }
        for (let i = 0; i < 4; i++) {
            const s = minEach + extraChips[i] * 100;
            document.getElementById('score' + i).value = s;
        }

        const mySeat = Math.floor(Math.random() * 4);
        const radios = document.getElementsByName('mySeat');
        for (let i = 0; i < radios.length; i++) {
            radios[i].checked = (i === mySeat);
        }
        highlightMe(mySeat);

        let raw = [0, 0, 0, 0];
        while (true) {
            raw[0] = Math.random() * 160 - 80;
            raw[1] = Math.random() * 160 - 80;
            raw[2] = Math.random() * 160 - 80;
            raw[3] = -(raw[0] + raw[1] + raw[2]);
            if (raw[3] >= -80 && raw[3] <= 80) break;
        }
        let r = [0, 0, 0, 0];
        r[0] = Math.round(raw[0] * 10) / 10;
        r[1] = Math.round(raw[1] * 10) / 10;
        r[2] = Math.round(raw[2] * 10) / 10;
        r[3] = -(r[0] + r[1] + r[2]);
        r[3] = Math.round(r[3] * 10) / 10;

        for (let i = 0; i < 4; i++) {
            document.getElementById('total' + i).value = r[i].toFixed(1);
        }

        const resultsDiv = document.getElementById('resultArea');
        resultsDiv.innerHTML = "<div style='text-align:center; color:#7f8c8d; padding:20px;'>ãƒ©ãƒ³ãƒ€ãƒ ãªçŠ¶æ³ã‚’ã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ã€Œè¨ˆç®—å®Ÿè¡Œã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>";

        updateStatusSummary();
    }

    function classifyDifficulty(list) {
        let minScore = Infinity;
        let hasAny = false;
        for (const o of list) {
            if (!o) continue;
            if (o.keepLead) {
                minScore = 0;
                hasAny = true;
                continue;
            }
            if (typeof o.score === "number" && o.score >= 0) {
                if (o.score < minScore) minScore = o.score;
                hasAny = true;
            }
        }
        if (!hasAny) return "neutral";

        if (minScore === 0 || minScore <= 1000) return "easy";
        if (minScore >= 24000) return "hard";
        return "neutral";
    }

    function rankArray(arr) {
        const order = arr.map((v, idx) => ({ v, idx }))
            .sort((a, b) => {
                if (b.v !== a.v) return b.v - a.v;
                return a.idx - b.idx;
            });
        const rankBySeat = {};
        order.forEach((o, i) => {
            rankBySeat[o.idx] = i + 1;
        });
        const topIdx = order[0].idx;
        return { rankBySeat, topIdx };
    }

    function buildAdvice(difficulty, me, target, scores, totalsBefore, scoreRankBySeat, totalRankBySeat) {
        const mySeat = me.seat;
        const myScoreRank = scoreRankBySeat[mySeat];
        const myTotalRank = totalRankBySeat[mySeat];
        const targetTotalRank = totalRankBySeat[target.seat];
        const ptDiff = totalsBefore[target.seat] - totalsBefore[mySeat];
        const ptGapAbs = Math.abs(ptDiff);

        if (myTotalRank === 1) {
            if (myScoreRank >= 3 && difficulty === "hard") {
                return "ç‚¹æ£’ã§ã¯ä¸‹ä½ã§ã™ãŒã€ãƒˆãƒ¼ã‚¿ãƒ«ã§ã¯ãƒˆãƒƒãƒ—ã§ã™ã€‚å€æº€ç´šã®æ‰‹ã‚’ç„¡ç†ã«ç‹™ã†ã‚ˆã‚Šã€æ”¾éŠƒã‚’é¿ã‘ã¦é †ä½ã‚’1ã¤ã§ã‚‚ä¸Šã’ã‚‰ã‚Œã‚Œã°ååˆ†ãªå±€é¢ã§ã™ã€‚å®‰å…¨å¯„ã‚Šã®æŠ¼ã—å¼•ãã§ã€è‡´å‘½å‚·ã ã‘ã¯é¿ã‘ã‚‹æ„è­˜ã‚’æŒã¡ã¾ã—ã‚‡ã†ã€‚";
            }
            if (difficulty === "hard") {
                return "ç·åˆãƒˆãƒƒãƒ—ã®ãŸã‚ã€ã“ã®ç›¸æ‰‹ã‚’ç„¡ç†ã«ã¾ãã‚Šã«è¡Œãå¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚å€æº€ç´šã®æ‰‹ãŒè‡ªç„¶ã«è¦‹ãˆãŸã¨ãã ã‘æ”»ã‚ã€åŸºæœ¬ã¯æ”¾éŠƒå›é¿ã‚’å„ªå…ˆã—ã¦ãƒˆãƒƒãƒ—ãƒ»2ç€ã‚­ãƒ¼ãƒ—ã‚’ç‹™ã†ã®ãŒç¾å®Ÿçš„ã§ã™ã€‚";
            }
            if (difficulty === "easy" && ptGapAbs < 50) {
                return "ç·åˆãƒˆãƒƒãƒ—ã ãŒç‚¹å·®ãƒ»ãƒã‚¤ãƒ³ãƒˆå·®ã¨ã‚‚ãã“ã¾ã§å¤§ããã‚ã‚Šã¾ã›ã‚“ã€‚ç„¡ç†ãªä»•æ›ã‘ã§æŒ¯ã‚Šè¾¼ã‚€ã¨ä¸€æ°—ã«å½¢å‹¢ãŒå¤‰ã‚ã‚‹ã®ã§ã€æ‰‹ãŒæ•´ã£ãŸå±€ã ã‘ã—ã£ã‹ã‚Šãƒªãƒ¼ãƒãƒ»åŠ ç‚¹ã‚’ç‹™ã„ã€ãã‚Œä»¥å¤–ã¯ã‚„ã‚„å®ˆå‚™å¯„ã‚Šã«æ§‹ãˆã‚‹ã¨ãƒãƒ©ãƒ³ã‚¹ãŒè‰¯ã„ã§ã™ã€‚";
            }
            if (difficulty === "easy") {
                return "ç·åˆãƒˆãƒƒãƒ—ã®çŠ¶æ…‹ã§æ¯”è¼ƒçš„è»½ã„æ¡ä»¶ã§ã•ã‚‰ã«å·®ã‚’åºƒã’ã‚‰ã‚Œã¾ã™ãŒã€å¤§ããªæ”¾éŠƒã§ãƒˆãƒƒãƒ—è»¢è½ã—ãªã„ã‚ˆã†ã«æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚å¥½é…ç‰Œã‚„å¥½å½¢ãƒªãƒ¼ãƒã®å±€ã§ã¯ç©æ¥µçš„ã«åŠ ç‚¹ã—ã€ãã‚Œä»¥å¤–ã§ã¯æŠ¼ã—éããªã„ãƒ¡ãƒªãƒãƒªã‚’ã¤ã‘ã‚‹ã¨è‰¯ã„ã§ã—ã‚‡ã†ã€‚";
            }
            if (myScoreRank === 1) {
                return "ç‚¹æ£’ãƒ»ãƒˆãƒ¼ã‚¿ãƒ«ã¨ã‚‚ã«ãƒˆãƒƒãƒ—ã§ã€ç‰¹åˆ¥ãªç„¡ç†ã‚’ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä»–å®¶ã®ç„¡ç†ãªãƒªãƒ¼ãƒã‚„ä»•æ›ã‘ã«ã¯ã¤ãã‚ã‚ãšã€æ‰‹ãŒã¾ã¨ã¾ã£ãŸå±€ã ã‘ãã¡ã‚“ã¨ã‚¢ã‚¬ã£ã¦å·®ã‚’ç¶­æŒãƒ»æ‹¡å¤§ã™ã‚‹ã‚¤ãƒ¡ãƒ¼ã‚¸ã§æ‰“ã¤ã®ãŒå®‰å…¨ã§ã™ã€‚";
            }
            return "ç·åˆãƒˆãƒƒãƒ—ã ãŒç‚¹æ£’ã§ã¯ãƒ“ãƒã‚¤ãƒ³ãƒ‰ã®ç›¸æ‰‹ã§ã™ã€‚ã‚ãã¾ã§ã€ç„¡ç†ã®ãªã„ç¯„å›²ã®æ”»ã‚ã€ã§ã€ãƒªãƒ¼ãƒã‚„æŠ¼ã—ã‚’é¸æŠã™ã‚‹å±€ã¨ã€ã‚ªãƒªã‚‹å±€ã‚’ã¯ã£ãã‚Šåˆ†ã‘ã¦ã„ãã¨ã€ãƒªã‚¹ã‚¯ã‚’æŠ‘ãˆãªãŒã‚‰ç€å®Ÿã«å·®ã‚’åºƒã’ã‚‰ã‚Œã¾ã™ã€‚";
        }

        if (difficulty === "easy") {
            if (ptDiff > 0 && targetTotalRank === 1 && ptGapAbs > 50) {
                return "ã“ã®ç›¸æ‰‹ãŒç·åˆãƒˆãƒƒãƒ—ã§ã€ã‹ã¤å¤§ãã‚ã®ãƒã‚¤ãƒ³ãƒˆå·®ãŒã‚ã‚Šã¾ã™ãŒã€æ¯”è¼ƒçš„è»½ã„æ‰‹ã§é€†è»¢ãŒç‹™ãˆã¾ã™ã€‚ã‚ªãƒ¼ãƒ©ã‚¹ä»˜è¿‘ãªã‚‰ã€å¤šå°‘ãƒªã‚¹ã‚¯ã‚’å–ã£ã¦ã§ã‚‚ãƒªãƒ¼ãƒã§ä¸€æ°—ã«ãƒˆãƒƒãƒ—ã‚’å¥ªã„ã«ã„ãä¾¡å€¤ã®ã‚ã‚‹å±€é¢ã§ã™ã€‚";
            } else if (ptDiff > 0 && targetTotalRank === 1) {
                return "ç·åˆãƒˆãƒƒãƒ—ã®ç›¸æ‰‹ã¨ãƒã‚¤ãƒ³ãƒˆå·®ã¯ãã“ã¾ã§å¤§ãããªãã€ç¾å®Ÿçš„ãªæ‰“ç‚¹ã§é€†è»¢å¯èƒ½ã§ã™ã€‚æ‰‹ãŒæ•´ã£ãŸå±€ã§ã¯ã—ã£ã‹ã‚Šãƒªãƒ¼ãƒã‚’æ‰“ã¡ã€ä»–å®¶ã®å‹•ãæ¬¡ç¬¬ã§ã¯ãƒ€ãƒãƒ»ãƒ„ãƒ¢ç‹™ã„ã‚‚è¦–é‡ã«å…¥ã‚ŒãŸæŸ”è»Ÿãªæ”»ã‚ãŒæœ‰åŠ¹ã§ã™ã€‚";
            } else if (ptDiff > 0) {
                return "ã“ã®ç›¸æ‰‹ã¨ã¯ãƒˆãƒ¼ã‚¿ãƒ«ã§ãƒ“ãƒã‚¤ãƒ³ãƒ‰ã§ã™ãŒã€æ‰‹ãŒã¾ã¨ã¾ã‚Œã°ååˆ†é€†è»¢ãŒç‹™ãˆã‚‹æ¡ä»¶ã§ã™ã€‚ãƒ©ã‚¹å›é¿ã‚ˆã‚Šã‚‚é †ä½ã‚¢ãƒƒãƒ—ãƒ»ãƒˆãƒƒãƒ—å–ã‚Šã‚’å„ªå…ˆã™ã‚‹å ´é¢ãªã‚‰ã€å¤šå°‘æŠ¼ã—æ°—å‘³ã«æ§‹ãˆã¦ã‚‚è‰¯ã„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã¨è¨€ãˆã¾ã™ã€‚";
            } else {
                return "ã“ã®ç›¸æ‰‹ã«ã¯ã™ã§ã«ãƒˆãƒ¼ã‚¿ãƒ«ã§ãƒªãƒ¼ãƒ‰ã—ã¦ã„ã¾ã™ãŒã€ã•ã‚‰ã«å·®ã‚’åºƒã’ã‚‹ãƒãƒ£ãƒ³ã‚¹ã§ã™ã€‚ãŸã ã—ã€ä»–å®¶ã«ã¾ãã‚‰ã‚Œã‚‹ãƒªã‚¹ã‚¯ã‚‚ã‚ã‚‹ãŸã‚ã€ç„¡ç†ãªæŠ¼ã—ã§å¤§ããæ·±è¿½ã„ã™ã‚‹ã‚ˆã‚Šã€è‰¯å½¢ãƒªãƒ¼ãƒã®å±€ã ã‘ã—ã£ã‹ã‚Šå–ã‚Šåˆ‡ã‚‹ã‚¹ã‚¿ã‚¤ãƒ«ãŒå®‰å®šã—ã¾ã™ã€‚";
            }
        }

        if (difficulty === "hard") {
            if (ptDiff > 0 && ptGapAbs > 80) {
                return "ã“ã®ç›¸æ‰‹ã‚’ãƒã‚¤ãƒ³ãƒˆã§ã‚‚ã¾ãã‚‹ã«ã¯ã€å€æº€ç´šä»¥ä¸Šãªã©ã‹ãªã‚Šå¤§ããªæ‰‹ãŒå¿…è¦ã§ã™ã€‚å±€é¢ã«ã‚ˆã£ã¦ã¯ã“ã®ç›¸æ‰‹ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‹ã‚‰å¤–ã—ã€ã‚ˆã‚Šç¾å®Ÿçš„ã«å±Šãç›¸æ‰‹ã‚’ç‹™ã£ãŸã‚Šã€ãƒ©ã‚¹å›é¿ã‚„2ç€ã‚­ãƒ¼ãƒ—ã‚’å„ªå…ˆã—ãŸæ–¹ãŒãƒˆãƒ¼ã‚¿ãƒ«ã®æˆç¸¾ã¯å®‰å®šã—ã¾ã™ã€‚";
            }
            return "ç‚¹æ•°ãƒ»ãƒã‚¤ãƒ³ãƒˆã®ä¸¡æ–¹ã§ã“ã®ç›¸æ‰‹ã‚’é€†è»¢ã™ã‚‹æ¡ä»¶ã¯ã‹ãªã‚Šé‡ãã€ç¾å®Ÿçš„ã«ã¯ã€ã¾ãã‚ŒãŸã‚‰ãƒ©ãƒƒã‚­ãƒ¼ã€ãƒ¬ãƒ™ãƒ«ã§ã™ã€‚å¿…è¦æ‰“ç‚¹ã‚’æ„è­˜ã—ã¤ã¤ã‚‚ã€ç„¡ç†ã«å…¨éƒ¨ã‚’è¿½ã„ã‹ã‘ãšã€ä»–å®¶ã¨ã®ç‚¹å·®ã‚„ãƒˆãƒ¼ã‚¿ãƒ«çŠ¶æ³ã‚’è¦‹ã¦ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æŸ”è»Ÿã«åˆ‡ã‚Šæ›¿ãˆã‚‹ã®ãŒè‰¯ã„ã§ã—ã‚‡ã†ã€‚";
        }

        if (myScoreRank === 1 && myTotalRank >= 3) {
            return "ã“ã®åŠè˜è‡ªä½“ã¯ãƒˆãƒƒãƒ—ç›®ã§ã™ãŒã€ãƒˆãƒ¼ã‚¿ãƒ«ã§ã¯ä¸‹ä½ã«æ²ˆã‚“ã§ã„ã¾ã™ã€‚ç¾å®Ÿçš„ãªæ‰“ç‚¹ã§ã“ã®ç›¸æ‰‹ã‚’ã¾ãã‚Œã‚‹ãªã‚‰ã€ã‚ªãƒ¼ãƒ©ã‚¹ã§ãƒˆãƒƒãƒ—ã‚’å®ˆã‚Šã¤ã¤ã‚‚ã€ãƒã‚¤ãƒ³ãƒˆå·®ã‚’è©°ã‚ã‚‰ã‚Œã‚‹æ”»ã‚ã©ã“ã‚ã§ã¯ã—ã£ã‹ã‚ŠæŠ¼ã—ã¦ã„ããŸã„å ´é¢ã§ã™ã€‚";
        }
        if (myScoreRank >= 3 && myTotalRank === 2) {
            return "ãƒˆãƒ¼ã‚¿ãƒ«2ä½ã§ã€ã“ã®ç›¸æ‰‹ã‚’ã¾ãã‚‹ã«ã¯ã‚ã‚‹ç¨‹åº¦ã®æ‰“ç‚¹ãŒå¿…è¦ã§ã™ã€‚ç„¡ç†ã«ä¸€å±€ã§æ±ºã‚ã«ã„ãã‚ˆã‚Šã€è¦ªç•ªã‚„å ´æ³ã®è‰¯ã„ã¨ã“ã‚ã§ã—ã£ã‹ã‚Šå‹è² ã‚’ã‹ã‘ã€æ‚ªã„å·¡ç›®ã‚„å ´æ³ã§ã¯ç´ ç›´ã«ã‚ªãƒªã‚‹ãƒ¡ãƒªãƒãƒªãŒé‡è¦ã§ã™ã€‚";
        }

        return "ã“ã®ç›¸æ‰‹ã¨ã¯ä¸­ã€œé«˜æ‰“ç‚¹ãŒã‚ã‚Œã°é€†è»¢ãŒè¦‹è¾¼ã‚ã¾ã™ã€‚å±€ã®æ®‹ã‚Šå·¡ç›®ã‚„è‡ªåˆ†ã®æ‰‹ã®ä¼¸ã³ã€ä»–å®¶ã®ä»•æ›ã‘ã‚„ãƒªãƒ¼ãƒçŠ¶æ³ã‚’è¦‹ãªãŒã‚‰ã€æŠ¼ã—å¼•ãã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚Šã¤ã¤ã€ãƒãƒ£ãƒ³ã‚¹å±€ã§ã—ã£ã‹ã‚Šå‰ã«å‡ºã‚‹ã¨ãƒˆãƒ¼ã‚¿ãƒ«ã§ã‚‚è‰¯ã„çµæœã«ç¹‹ãŒã‚Šã‚„ã™ããªã‚Šã¾ã™ã€‚";
    }

    function calculate() {
        cardCounter = 0;

        let kyotaku = parseInt(document.getElementById('kyotaku').value, 10) || 0;
        const honba   = parseInt(document.getElementById('honba').value, 10) || 0;

        const resultsDiv = document.getElementById('resultArea');
        resultsDiv.innerHTML = "";

        let players = [];
        let scoresBefore = [];
        let myIndex = getMySeat();
        for (let i = 0; i < 4; i++) {
            const s = parseInt(document.getElementById('score' + i).value, 10) || 0;
            scoresBefore[i] = s;
            players.push({
                seat: i,
                name: winds[i],
                score: s,
                isParent: (i === 0)
            });
        }

        const totalsBefore = [];
        for (let i = 0; i < 4; i++) {
            totalsBefore[i] = parseFloat(document.getElementById('total' + i).value) || 0;
        }

        const returnPoint = parseInt(document.getElementById('returnPoint').value, 10) || 30000;
        const okaPt = parseFloat(document.getElementById('oka').value) || 0;
        const uma = [];
        for (let i = 0; i < 4; i++) {
            uma[i] = parseFloat(document.getElementById('uma' + i).value) || 0;
        }

        const scoreRankInfo = rankArray(scoresBefore);
        const totalRankInfo = rankArray(totalsBefore);
        const scoreRankBySeat = scoreRankInfo.rankBySeat;
        const totalRankBySeat = totalRankInfo.rankBySeat;

        const myScoreRank0 = scoreRankBySeat[myIndex];
        const myTotalRank0 = totalRankBySeat[myIndex];

        const viewModeEl = document.getElementById('viewMode');
        const viewMode = viewModeEl ? viewModeEl.value : 'attack';

        const pot = kyotaku * 1000;
        const me = players[myIndex];

        if (viewMode === 'defense') {
            calculateDefense(players, scoresBefore, totalsBefore, me, pot, honba, uma, okaPt, returnPoint, myTotalRank0);
            updateStatusSummary();
            return;
        }

        // --- ã“ã“ã‹ã‚‰æ”»æ’ƒãƒ¢ãƒ¼ãƒ‰ï¼ˆå¾“æ¥ã®æ‰“å€’æ¡ä»¶ï¼‰ ---
        let scoreTargets = players.filter(p => p.seat !== myIndex && p.score >= me.score);
        scoreTargets.sort((a, b) => b.score - a.score);

        let pointTargets = players.filter(p => p.seat !== myIndex && totalsBefore[p.seat] >= totalsBefore[myIndex]);
        pointTargets.sort((a, b) => totalsBefore[b.seat] - totalsBefore[a.seat]);

        if (scoreTargets.length === 0 && pointTargets.length === 0) {
            resultsDiv.innerHTML =
                "<div style='text-align:center; padding:20px; font-weight:bold; color:#27ae60;'>" +
                "ç¾åœ¨ã€ç‚¹æ£’ã‚‚ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆã‚‚ãƒˆãƒƒãƒ—ã§ã™ï¼<br>ç„¡ç†ã«åŠ ç‚¹ã‚’ç‹™ã†ã‚ˆã‚Šæ”¾éŠƒå›é¿ã‚’å„ªå…ˆã—ã€ã“ã®å±€ã‚’å®‰å…¨ã«çµ‚ã‚ã‚‰ã›ã‚‹ã“ã¨ã‚’è€ƒãˆã¾ã—ã‚‡ã†ã€‚" +
                "</div>";
            updateStatusSummary();
            return;
        }

        const processedSeats = new Set();

        // ç‚¹æ£’ã§ã‚‚è² ã‘ã¦ã„ã‚‹ç›¸æ‰‹ï¼ˆæ‰“å€’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰
        scoreTargets.forEach(target => {
            processedSeats.add(target.seat);
            const diff = target.score - me.score;
            const ptDiff = totalsBefore[target.seat] - totalsBefore[myIndex];
            const alreadyLeadInPoint = (totalsBefore[myIndex] > totalsBefore[target.seat]);

            let directScoreRes = null;
            let directPointRes = null;
            let tsumoScoreRes = null;
            let tsumoPointRes = null;
            let otherScoreRes = null;
            let otherPointRes = null;

            const needDirectRaw = (diff - (2 * honba * 300) - pot) / 2;
            directScoreRes = findMinHandForRon(needDirectRaw, me.isParent);
            if (directScoreRes) {
                const handInfo = scoreHand(directScoreRes.han, directScoreRes.fu, me.isParent);
                const afterPlayers = simulateDirectRon(me, target, players, handInfo.ron, pot, honba);
                const ptInfo = calcTotalDiff(afterPlayers, me.seat, target.seat, uma, okaPt, returnPoint, totalsBefore);
                const ptStr = makePtText(ptInfo, target.name);
                directScoreRes.ptText = ptStr;
                directScoreRes.diffLabel = ptInfo.diffLabel;
                directScoreRes.text   = `${handInfo.label}ï¼ˆãƒ­ãƒ³ ${handInfo.ron}ç‚¹ï¼‰`;
                directScoreRes.score  = handInfo.ron;
            }

            if (alreadyLeadInPoint) {
                const leadGap = totalsBefore[myIndex] - totalsBefore[target.seat];
                directPointRes = {
                    score: 0,
                    text: "å’Œäº†ã™ã‚‹ã ã‘ã§ãƒã‚¤ãƒ³ãƒˆãƒªãƒ¼ãƒ‰ç¶­æŒï¼ˆã™ã§ã«ãƒˆãƒ¼ã‚¿ãƒ«ãƒˆãƒƒãƒ—ï¼‰",
                    ptText: "",
                    han: 0,
                    fu: 0,
                    keepLead: true,
                    diffLabel: `å·® ${leadGap.toFixed(1)}ptãƒ»ãƒªãƒ¼ãƒ‰ç¶­æŒ`
                };
            } else {
                directPointRes = findMinHandForRonPointReverse(
                    me, target, players, pot, honba,
                    uma, okaPt, returnPoint, totalsBefore
                );
            }

            tsumoScoreRes = findTsumoCondition(me, target, players, pot, honba);
            if (tsumoScoreRes) {
                const handInfo = scoreHand(tsumoScoreRes.han, tsumoScoreRes.fu, me.isParent);
                const afterPlayers = simulateTsumoWithHand(me, players, handInfo, pot, honba);
                const ptInfo = calcTotalDiff(afterPlayers, me.seat, target.seat, uma, okaPt, returnPoint, totalsBefore);
                const ptStr = makePtText(ptInfo, target.name);
                tsumoScoreRes.ptText = ptStr;
                tsumoScoreRes.diffLabel = ptInfo.diffLabel;
                tsumoScoreRes.text   = `${handInfo.label}ï¼ˆ${getTsumoDesc(handInfo, me.isParent)}ï¼‰`;
                tsumoScoreRes.score  = handInfo.ron;
            }

            if (alreadyLeadInPoint) {
                const leadGap = totalsBefore[myIndex] - totalsBefore[target.seat];
                tsumoPointRes = {
                    score: 0,
                    text: "å’Œäº†ã™ã‚‹ã ã‘ã§ãƒã‚¤ãƒ³ãƒˆãƒªãƒ¼ãƒ‰ç¶­æŒï¼ˆã™ã§ã«ãƒˆãƒ¼ã‚¿ãƒ«ãƒˆãƒƒãƒ—ï¼‰",
                    ptText: "",
                    han: 0,
                    fu: 0,
                    keepLead: true,
                    diffLabel: `å·® ${leadGap.toFixed(1)}ptãƒ»ãƒªãƒ¼ãƒ‰ç¶­æŒ`
                };
            } else {
                tsumoPointRes = findTsumoPointReverse(
                    me, target, players, pot, honba,
                    uma, okaPt, returnPoint, totalsBefore
                );
            }

            const needOtherRaw = diff - honba * 300 - pot;
            otherScoreRes = findMinHandForRon(needOtherRaw, me.isParent);
            if (otherScoreRes) {
                const handInfo = scoreHand(otherScoreRes.han, otherScoreRes.fu, me.isParent);
                const afterPlayers = simulateSideRon(me, target, players, handInfo.ron, pot, honba);
                const ptInfo = calcTotalDiff(afterPlayers, me.seat, target.seat, uma, okaPt, returnPoint, totalsBefore);
                const ptStr = makePtText(ptInfo, target.name);
                otherScoreRes.ptText = ptStr;
                otherScoreRes.diffLabel = ptInfo.diffLabel;
                otherScoreRes.text   = `${handInfo.label}ï¼ˆãƒ­ãƒ³ ${handInfo.ron}ç‚¹ï¼‰`;
                otherScoreRes.score  = handInfo.ron;
            }

            if (alreadyLeadInPoint) {
                const leadGap = totalsBefore[myIndex] - totalsBefore[target.seat];
                otherPointRes = {
                    score: 0,
                    text: "å’Œäº†ã™ã‚‹ã ã‘ã§ãƒã‚¤ãƒ³ãƒˆãƒªãƒ¼ãƒ‰ç¶­æŒï¼ˆã™ã§ã«ãƒˆãƒ¼ã‚¿ãƒ«ãƒˆãƒƒãƒ—ï¼‰",
                    ptText: "",
                    han: 0,
                    fu: 0,
                    keepLead: true,
                    diffLabel: `å·® ${leadGap.toFixed(1)}ptãƒ»ãƒªãƒ¼ãƒ‰ç¶­æŒ`
                };
            } else {
                otherPointRes = findMinHandForSideRonPointReverse(
                    me, target, players, pot, honba,
                    uma, okaPt, returnPoint, totalsBefore
                );
            }

            const difficulty = classifyDifficulty([
                directScoreRes, tsumoScoreRes, otherScoreRes,
                directPointRes, tsumoPointRes, otherPointRes
            ]);

            let cardClass = "target-card";
            let highlightIcon = "";
            let collapsed = false;

            if (difficulty === "easy") {
                cardClass += " target-card-easy";
                highlightIcon = '<span class="chance-badge">ãƒãƒ£ãƒ³ã‚¹ï¼</span>';
            } else if (difficulty === "hard") {
                cardClass += " target-card-hard";
                collapsed = true;
            }

            const cardId = `cardBody_${cardCounter++}`;
            const bodyStyle = collapsed ? " style='display:none;'" : "";
            const toggleLabel = collapsed ? "è©³ç´°ã‚’è¡¨ç¤º" : "è©³ç´°ã‚’éš ã™";

            let html = `<div class="${cardClass}">`;
            html += `<div class="target-header">
                        <span>${highlightIcon}æ‰“å€’: ${target.name}</span>
                        <div class="target-header-right">
                            <span>ç‚¹å·®: ${diff}ç‚¹ / Ptå·®: ${ptDiff.toFixed(1)}pt</span>
                            <button type="button" class="card-toggle-btn" onclick="toggleCardBody('${cardId}', this)">${toggleLabel}</button>
                        </div>
                     </div>`;
            html += `<div id="${cardId}"${bodyStyle}>`;

            html += makeRowDual("ç›´æ’ƒ", "ç‚¹æ•°é€†è»¢", "ãƒã‚¤ãƒ³ãƒˆé€†è»¢", directScoreRes, directPointRes);
            html += makeRowDual("ãƒ„ãƒ¢", "ç‚¹æ•°é€†è»¢", "ãƒã‚¤ãƒ³ãƒˆé€†è»¢", tsumoScoreRes, tsumoPointRes);
            html += makeRowDual("è„‡ã‹ã‚‰å‡ºã‚ãŒã‚Š", "ç‚¹æ•°é€†è»¢", "ãƒã‚¤ãƒ³ãƒˆé€†è»¢", otherScoreRes, otherPointRes, "ä»–å®¶ã‹ã‚‰ãƒ­ãƒ³ï¼ˆç‚¹æ•°ãŒä¸€ç•ªä½ã„ä»–å®¶ã‚’æ”¾éŠƒè€…ã¨ä»®å®šï¼‰");

            const advice = buildAdvice(difficulty, me, target, scoresBefore, totalsBefore, scoreRankBySeat, totalRankBySeat);
            html += `<div class="mini-note"><strong>æˆ¦ç•¥ã‚¢ãƒ‰ãƒã‚¤ã‚¹ï¼š</strong>${advice}</div>`;

            html += `</div></div>`;
            resultsDiv.innerHTML += html;
        });

        // ç‚¹æ£’ã§ã¯å‹ã£ã¦ã„ã‚‹ãŒã€ãƒˆãƒ¼ã‚¿ãƒ«ã§è² ã‘ã¦ã„ã‚‹ç›¸æ‰‹
        pointTargets.forEach(target => {
            if (processedSeats.has(target.seat)) return;

            const ptDiff = totalsBefore[target.seat] - totalsBefore[myIndex];
            const scoreDiff = target.score - me.score;

            let directScoreRes = null;
            let tsumoScoreRes  = null;
            let otherScoreRes  = null;

            let directPointRes = findMinHandForRonPointReverse(
                me, target, players, pot, honba,
                uma, okaPt, returnPoint, totalsBefore
            );
            let tsumoPointRes = findTsumoPointReverse(
                me, target, players, pot, honba,
                uma, okaPt, returnPoint, totalsBefore
            );
            let otherPointRes = findMinHandForSideRonPointReverse(
                me, target, players, pot, honba,
                uma, okaPt, returnPoint, totalsBefore
            );

            const difficulty = classifyDifficulty([
                directScoreRes, tsumoScoreRes, otherScoreRes,
                directPointRes, tsumoPointRes, otherPointRes
            ]);

            let cardClass = "target-card";
            let highlightIcon = "";
            let collapsed = false;

            if (difficulty === "easy") {
                cardClass += " target-card-easy";
                highlightIcon = '<span class="chance-badge">ãƒãƒ£ãƒ³ã‚¹ï¼</span>';
            } else if (difficulty === "hard") {
                cardClass += " target-card-hard";
                collapsed = true;
            }

            const cardId = `cardBody_${cardCounter++}`;
            const bodyStyle = collapsed ? " style='display:none;'" : "";
            const toggleLabel = collapsed ? "è©³ç´°ã‚’è¡¨ç¤º" : "è©³ç´°ã‚’éš ã™";

            let html = `<div class="${cardClass}">`;
            html += `<div class="target-header">
                        <span>${highlightIcon}æ‰“å€’: ${target.name}</span>
                        <div class="target-header-right">
                            <span>Ptå·®: ${ptDiff.toFixed(1)}pt / ç‚¹å·®: ${scoreDiff}ç‚¹</span>
                            <button type="button" class="card-toggle-btn" onclick="toggleCardBody('${cardId}', this)">${toggleLabel}</button>
                        </div>
                     </div>`;
            html += `<div id="${cardId}"${bodyStyle}>`;

            html += makeRowDual("ç›´æ’ƒ", "ç‚¹æ•°é€†è»¢", "ãƒã‚¤ãƒ³ãƒˆé€†è»¢", directScoreRes, directPointRes);
            html += makeRowDual("ãƒ„ãƒ¢", "ç‚¹æ•°é€†è»¢", "ãƒã‚¤ãƒ³ãƒˆé€†è»¢", tsumoScoreRes, tsumoPointRes);
            html += makeRowDual("è„‡ã‹ã‚‰å‡ºã‚ãŒã‚Š", "ç‚¹æ•°é€†è»¢", "ãƒã‚¤ãƒ³ãƒˆé€†è»¢", otherScoreRes, otherPointRes, "ä»–å®¶ã‹ã‚‰ãƒ­ãƒ³ï¼ˆç‚¹æ•°ãŒä¸€ç•ªä½ã„ä»–å®¶ã‚’æ”¾éŠƒè€…ã¨ä»®å®šï¼‰");

            const advice = buildAdvice(difficulty, me, target, scoresBefore, totalsBefore, scoreRankBySeat, totalRankBySeat);
            html += `<div class="mini-note"><strong>æˆ¦ç•¥ã‚¢ãƒ‰ãƒã‚¤ã‚¹ï¼š</strong>${advice}</div>`;

            html += `</div></div>`;
            resultsDiv.innerHTML += html;
        });

        updateStatusSummary();
    }

    function toggleCardBody(id, btn) {
        const el = document.getElementById(id);
        if (!el) return;
        if (el.style.display === 'none') {
            el.style.display = 'block';
            if (btn) btn.textContent = "è©³ç´°ã‚’éš ã™";
        } else {
            el.style.display = 'none';
            if (btn) btn.textContent = "è©³ç´°ã‚’è¡¨ç¤º";
        }
    }

    function findMinHandForRon(threshold, isParent) {
        if (threshold <= 0) {
            const baseHand = candidateHands[0];
            const h = scoreHand(baseHand.han, baseHand.fu, isParent);
            return {
                score: 0,
                text: `ã‚¢ã‚¬ã‚Šã•ãˆã™ã‚Œã°é€†è»¢ï¼ˆ${h.label}ä»¥ä¸Šï¼‰`,
                han: baseHand.han,
                fu: baseHand.fu
            };
        }

        let best = null;
        for (const cand of candidateHands) {
            const h = scoreHand(cand.han, cand.fu, isParent);
            if (h.ron > threshold) {
                if (!best || h.ron < best.score) {
                    best = {
                        score: h.ron,
                        text: h.label,
                        han: cand.han,
                        fu: cand.fu
                    };
                }
            }
        }
        return best;
    }

    function findTsumoCondition(me, target, players, pot, honba) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, me.isParent).ron;
            const pb = scoreHand(b.han, b.fu, me.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, me.isParent);
            const after = simulateTsumoWithHand(me, players, handInfo, pot, honba);
            const myAfter = after[me.seat].score;
            const targetAfter = after[target.seat].score;
            if (myAfter > targetAfter) {
                return {
                    score: handInfo.ron,
                    text: handInfo.label,
                    han: cand.han,
                    fu: cand.fu
                };
            }
        }
        return null;
    }

    function findMinHandForRonPointReverse(
        me, target, players, pot, honba,
        uma, okaPt, returnPoint, totalsBefore
    ) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, me.isParent).ron;
            const pb = scoreHand(b.han, b.fu, me.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, me.isParent);
            const afterPlayers = simulateDirectRon(me, target, players, handInfo.ron, pot, honba);
            const ptInfo = calcTotalDiff(afterPlayers, me.seat, target.seat, uma, okaPt, returnPoint, totalsBefore);
            if (ptInfo.diffAfter > 0) {
                const ptStr = makePtText(ptInfo, target.name);
                return {
                    score: handInfo.ron,
                    text: `${handInfo.label}ï¼ˆãƒ­ãƒ³ ${handInfo.ron}ç‚¹ï¼‰`,
                    ptText: ptStr,
                    han: cand.han,
                    fu: cand.fu,
                    diffLabel: ptInfo.diffLabel
                };
            }
        }
        return null;
    }

    function findTsumoPointReverse(
        me, target, players, pot, honba,
        uma, okaPt, returnPoint, totalsBefore
    ) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, me.isParent).ron;
            const pb = scoreHand(b.han, b.fu, me.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, me.isParent);
            const afterPlayers = simulateTsumoWithHand(me, players, handInfo, pot, honba);
            const ptInfo = calcTotalDiff(afterPlayers, me.seat, target.seat, uma, okaPt, returnPoint, totalsBefore);
            if (ptInfo.diffAfter > 0) {
                const ptStr = makePtText(ptInfo, target.name);
                return {
                    score: handInfo.ron,
                    text: `${handInfo.label}ï¼ˆ${getTsumoDesc(handInfo, me.isParent)}ï¼‰`,
                    ptText: ptStr,
                    han: cand.han,
                    fu: cand.fu,
                    diffLabel: ptInfo.diffLabel
                };
            }
        }
        return null;
    }

    function findMinHandForSideRonPointReverse(
        me, target, players, pot, honba,
        uma, okaPt, returnPoint, totalsBefore
    ) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, me.isParent).ron;
            const pb = scoreHand(b.han, b.fu, me.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, me.isParent);
            const afterPlayers = simulateSideRon(me, target, players, handInfo.ron, pot, honba);
            const ptInfo = calcTotalDiff(afterPlayers, me.seat, target.seat, uma, okaPt, returnPoint, totalsBefore);
            if (ptInfo.diffAfter > 0) {
                const ptStr = makePtText(ptInfo, target.name);
                return {
                    score: handInfo.ron,
                    text: `${handInfo.label}ï¼ˆãƒ­ãƒ³ ${handInfo.ron}ç‚¹ï¼‰`,
                    ptText: ptStr,
                    han: cand.han,
                    fu: cand.fu,
                    diffLabel: ptInfo.diffLabel
                };
            }
        }
        return null;
    }

    function makeRowDual(mainLabel, scoreLabel, pointLabel, scoreRes, pointRes, extraDesc) {
        if (!scoreRes && !pointRes) {
            return `
                <div class="cond-block">
                    <div class="condition-row">
                        <span class="condition-main-label">${mainLabel}</span>
                        <span class="condition-val" style="color:#95a5a6;">ã“ã®æ¡ä»¶ã§ã¯é€†è»¢ä¸å¯</span>
                    </div>
                </div>
            `;
        }

        let html = `<div class="cond-block"><div class="condition-row"><span class="condition-main-label">${mainLabel}</span><span></span></div>`;

        const sameHand =
            scoreRes && pointRes &&
            !pointRes?.keepLead &&
            scoreRes.han === pointRes.han &&
            scoreRes.fu === pointRes.fu &&
            scoreRes.score === pointRes.score;

        if (sameHand) {
            let scoreDisplay = scoreRes.score >= 32000
                ? "å½¹æº€ç´š"
                : (scoreRes.score > 0 ? scoreRes.score + "ç‚¹" : "æ¡ä»¶é”æˆæ¸ˆ");

            const diffLabel = pointRes && pointRes.diffLabel ? `ï¼ˆ${pointRes.diffLabel}ï¼‰` : "";

            html += `
                <div class="condition-row">
                    <span class="condition-label-strong">${scoreLabel}ãƒ»${pointLabel}${diffLabel}</span>
                    <span class="condition-val">${scoreDisplay}</span>
                </div>
                <div class="condition-detail">
                    ${scoreRes.text}<br>
                    ${scoreRes.ptText || pointRes.ptText || ""}
                    ${extraDesc ? "<br>" + extraDesc : ""}
                </div>
            `;
        } else {
            if (scoreRes) {
                let sd = scoreRes.score >= 32000
                    ? "å½¹æº€ç´š"
                    : (scoreRes.score > 0 ? scoreRes.score + "ç‚¹" : "æ¡ä»¶é”æˆæ¸ˆ");
                const diffLabel = scoreRes.diffLabel ? `ï¼ˆ${scoreRes.diffLabel}ï¼‰` : "";
                html += `
                    <div class="condition-row">
                        <span class="condition-label-strong">${scoreLabel}${diffLabel}</span>
                        <span class="condition-val">${sd}</span>
                    </div>
                    <div class="condition-detail">
                        ${scoreRes.text}<br>
                        ${scoreRes.ptText || ""}
                        ${extraDesc ? "<br>" + extraDesc : ""}
                    </div>
                `;
            }
            if (pointRes) {
                const isKeep = pointRes.keepLead === true;
                const labelText = isKeep ? "ãƒã‚¤ãƒ³ãƒˆç¶­æŒ" : pointLabel;
                let pd;
                if (isKeep) {
                    pd = "å’Œäº†ã™ã‚‹ã ã‘";
                } else {
                    pd = pointRes.score >= 32000
                        ? "å½¹æº€ç´š"
                        : (pointRes.score > 0 ? pointRes.score + "ç‚¹" : "æ¡ä»¶é”æˆæ¸ˆ");
                }
                const diffLabel = pointRes.diffLabel ? `ï¼ˆ${pointRes.diffLabel}ï¼‰` : "";
                html += `
                    <div class="condition-row">
                        <span class="condition-label-strong">${labelText}${diffLabel}</span>
                        <span class="condition-val">${pd}</span>
                    </div>
                    <div class="condition-detail">
                        ${pointRes.text}<br>
                        ${pointRes.ptText || ""}
                        ${extraDesc && !scoreRes ? "<br>" + (extraDesc || "") : ""}
                    </div>
                `;
            }
        }
        html += `</div>`;
        return html;
    }

    function makeDefenseRow(mainLabel, res) {
        if (!res) {
            return `
                <div class="cond-block">
                    <div class="condition-row">
                        <span class="condition-main-label">${mainLabel}</span>
                        <span class="condition-val" style="color:#27ae60;">ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯é †ä½ã¯è½ã¡ã¾ã›ã‚“</span>
                    </div>
                </div>
            `;
        }

        let sd = res.score >= 32000
            ? "å½¹æº€ç´š"
            : (res.score > 0 ? res.score + "ç‚¹" : "æ¡ä»¶ãªã—");

        const rankText = `ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ï¼š${res.beforeRank}ä½ â†’ ${res.afterRank}ä½`;

        return `
            <div class="cond-block">
                <div class="condition-row">
                    <span class="condition-main-label">${mainLabel}</span>
                    <span class="condition-val">${sd}</span>
                </div>
                <div class="condition-detail">
                    ${rankText}<br>
                    ${res.text}
                </div>
            </div>
        `;
    }

    function clonePlayers(players) {
        return players.map(p => ({ ...p }));
    }

    function simulateDirectRon(me, target, players, ronPoint, pot, honba) {
        const after = clonePlayers(players);
        const honbaBonus = honba * 300;
        after[me.seat].score     += ronPoint + honbaBonus + pot;
        after[target.seat].score -= ronPoint + honbaBonus;
        return after;
    }

    function simulateSideRon(me, target, players, ronPoint, pot, honba) {
        const after = clonePlayers(players);
        const honbaBonus = honba * 300;

        const candidates = after.filter(p => p.seat !== me.seat && p.seat !== target.seat);
        candidates.sort((a, b) => a.score - b.score);
        const loserSeat = candidates[0].seat;

        after[me.seat].score   += ronPoint + honbaBonus + pot;
        after[loserSeat].score -= ronPoint + honbaBonus;
        return after;
    }

    function simulateTsumoWithHand(me, players, handInfo, pot, honba) {
        const after = clonePlayers(players);
        const honbaPlus = honba * 300;
        const honbaMinus = honba * 100;
        const parentSeat = players.find(p => p.isParent).seat;

        if (me.isParent) {
            const payEach = handInfo.tsumoEach;
            for (let i = 0; i < after.length; i++) {
                if (i === me.seat) {
                    after[i].score += payEach * 3 + honbaPlus + pot;
                } else {
                    after[i].score -= payEach + honbaMinus;
                }
            }
        } else {
            const fromParent = handInfo.tsumoFromParent;
            const fromChild  = handInfo.tsumoFromChild;
            for (let i = 0; i < after.length; i++) {
                if (i === me.seat) {
                    after[i].score += fromParent + fromChild * 2 + honbaPlus + pot;
                } else if (i === parentSeat) {
                    after[i].score -= fromParent + honbaMinus;
                } else {
                    after[i].score -= fromChild + honbaMinus;
                }
            }
        }
        return after;
    }

    function getTsumoDesc(handInfo, isParent) {
        if (isParent) {
            return `è¦ªãƒ„ãƒ¢ï¼š${handInfo.tsumoEach}ã‚ªãƒ¼ãƒ«`;
        } else {
            return `å­ãƒ„ãƒ¢ï¼šè¦ª ${handInfo.tsumoFromParent}ç‚¹ãƒ»å­ ${handInfo.tsumoFromChild}ç‚¹`;
        }
    }

    function calcTotalDiff(afterPlayers, mySeat, targetSeat, uma, okaPt, returnPoint, totalsBefore) {
        const sorted = [...afterPlayers].sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return a.seat - b.seat;
        });

        const rankBySeat = {};
        sorted.forEach((p, idx) => {
            rankBySeat[p.seat] = idx;
        });

        const thisHanPtBySeat = {};
        for (const p of afterPlayers) {
            const rank = rankBySeat[p.seat];
            const base = (p.score - returnPoint) / 1000;
            const umaVal = uma[rank] || 0;
            const okaVal = (rank === 0 ? okaPt : 0);
            thisHanPtBySeat[p.seat] = base + umaVal + okaVal;
        }

        const totalAfter = {};
        for (let seat = 0; seat < 4; seat++) {
            const before = totalsBefore[seat] || 0;
            totalAfter[seat] = before + (thisHanPtBySeat[seat] || 0);
        }

        return {
            myAfter: totalAfter[mySeat],
            targetAfter: totalAfter[targetSeat],
            diffAfter: totalAfter[mySeat] - totalAfter[targetSeat],
            myThisHan: thisHanPtBySeat[mySeat],
            targetThisHan: thisHanPtBySeat[targetSeat]
        };
    }

    function calcTotalsForAll(afterPlayers, uma, okaPt, returnPoint, totalsBefore) {
        const sorted = [...afterPlayers].sort((a, b) => {
            if (b.score !== a.score) return b.score - a.score;
            return a.seat - b.seat;
        });

        const rankBySeat = {};
        sorted.forEach((p, idx) => {
            rankBySeat[p.seat] = idx;
        });

        const thisHanPtBySeat = {};
        const totalAfter = {};
        for (const p of afterPlayers) {
            const rank = rankBySeat[p.seat];
            const base = (p.score - returnPoint) / 1000;
            const umaVal = uma[rank] || 0;
            const okaVal = (rank === 0 ? okaPt : 0);
            thisHanPtBySeat[p.seat] = base + umaVal + okaVal;
        }
        for (let seat = 0; seat < 4; seat++) {
            const before = totalsBefore[seat] || 0;
            totalAfter[seat] = before + (thisHanPtBySeat[seat] || 0);
        }
        return { thisHanPtBySeat, totalAfter };
    }

    function makePtText(ptInfo, targetName) {
        const myAfter   = ptInfo.myAfter.toFixed(1);
        const tgAfter   = ptInfo.targetAfter.toFixed(1);
        const diffAfter = ptInfo.diffAfter.toFixed(1);
        const myThis    = ptInfo.myThisHan.toFixed(1);
        const tgThis    = ptInfo.targetThisHan.toFixed(1);

        let status = "åŒç‚¹";
        if (ptInfo.diffAfter > 0) status = "ãƒªãƒ¼ãƒ‰";
        else if (ptInfo.diffAfter < 0) status = "ãƒ“ãƒã‚¤ãƒ³ãƒ‰";

        const diffAbs = Math.abs(ptInfo.diffAfter).toFixed(1);
        ptInfo.diffLabel = `å·® ${diffAbs}ptãƒ»${status}`;

        return `ã“ã®åŠè˜ã®åæ”¯ï¼šè‡ªåˆ† ${myThis}pt / ${targetName} ${tgThis}ptã€‚ã€€çµ‚äº†æ™‚ãƒˆãƒ¼ã‚¿ãƒ«ï¼šè‡ªåˆ† ${myAfter}pt / ${targetName} ${tgAfter}ptï¼ˆå·® ${diffAfter}ptãƒ»${status}ï¼‰ã€‚`;
    }

    function updateStatusSummary() {
        const scores = [];
        const totals = [];
        for (let i = 0; i < 4; i++) {
            scores[i] = parseInt(document.getElementById('score' + i).value, 10) || 0;
            totals[i] = parseFloat(document.getElementById('total' + i).value) || 0;
        }
        const mySeat = getMySeat();

        const scoreRank = rankArray(scores);
        const totalRank = rankArray(totals);

        const myScoreRank = scoreRank.rankBySeat[mySeat];
        const myTotalRank = totalRank.rankBySeat[mySeat];

        const scoreDiff = scores[scoreRank.topIdx] - scores[mySeat];
        const totalDiff = totals[totalRank.topIdx] - totals[mySeat];

        let scoreClass = "status-ok";
        if (myScoreRank === 1) scoreClass = "status-ok";
        else if (myScoreRank === 2) scoreClass = "status-warn";
        else scoreClass = "status-bad";

        let totalClass = "status-ok";
        if (myTotalRank === 1) totalClass = "status-ok";
        else if (myTotalRank === 2) totalClass = "status-warn";
        else totalClass = "status-bad";

        const el = document.getElementById('statusSummary');
        if (!el) return;

        const scoreLine = (myScoreRank === 1)
            ? `ç‚¹æ£’é †ä½ï¼š1ä½ï¼ˆ2ä½ã¨ã®å·® ${Math.abs(scoreDiff)}ç‚¹ï¼‰`
            : `ç‚¹æ£’é †ä½ï¼š${myScoreRank}ä½ï¼ˆãƒˆãƒƒãƒ—ã¨ ${scoreDiff < 0 ? "-" : "+"}${Math.abs(scoreDiff)}ç‚¹ï¼‰`;

        const totalLine = (myTotalRank === 1)
            ? `ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ï¼š1ä½ï¼ˆ2ä½ã¨ã®å·® ${Math.abs(totalDiff).toFixed(1)}ptï¼‰`
            : `ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ï¼š${myTotalRank}ä½ï¼ˆãƒˆãƒƒãƒ—ã¨ ${totalDiff < 0 ? "-" : "+"}${Math.abs(totalDiff).toFixed(1)}ptï¼‰`;

        el.innerHTML =
            `<div class="status-line ${scoreClass}">${scoreLine}</div>` +
            `<div class="status-line ${totalClass}">${totalLine}</div>`;
    }

    function updateSimWinType() {
        const winType = document.getElementById('simWinType').value;
        const row = document.getElementById('simRonTargetRow');
        if (winType === 'tsumo') {
            row.style.display = 'none';
        } else {
            row.style.display = 'flex';
        }
    }

    function simulateCustomHand() {
        const han = parseInt(document.getElementById('simHan').value, 10) || 0;
        const fu  = parseInt(document.getElementById('simFu').value, 10) || 0;
        const winType = document.getElementById('simWinType').value;
        const targetSeatForRon = parseInt(document.getElementById('simRonTarget').value, 10) || 0;

        const kyotakuBase = parseInt(document.getElementById('kyotaku').value, 10) || 0;
        const honba   = parseInt(document.getElementById('honba').value, 10) || 0;

        const returnPoint = parseInt(document.getElementById('returnPoint').value, 10) || 30000;
        const okaPt = parseFloat(document.getElementById('oka').value) || 0;
        const uma = [];
        for (let i = 0; i < 4; i++) {
            uma[i] = parseFloat(document.getElementById('uma' + i).value) || 0;
        }

        const totalsBefore = [];
        const scoresBefore = [];
        for (let i = 0; i < 4; i++) {
            scoresBefore[i] = parseInt(document.getElementById('score' + i).value, 10) || 0;
            totalsBefore[i] = parseFloat(document.getElementById('total' + i).value) || 0;
        }

        let players = [];
        const mySeat = getMySeat();
        for (let i = 0; i < 4; i++) {
            players.push({
                seat: i,
                name: winds[i],
                score: scoresBefore[i],
                isParent: (i === 0)
            });
        }

        const kyotaku = kyotakuBase;
        const pot = kyotaku * 1000;

        const me = players[mySeat];
        const handInfo = scoreHand(han, fu, me.isParent);

        let afterPlayers = null;
        if (winType === 'ron') {
            const target = players[targetSeatForRon];
            afterPlayers = simulateDirectRon(me, target, players, handInfo.ron, pot, honba);
        } else {
            afterPlayers = simulateTsumoWithHand(me, players, handInfo, pot, honba);
        }

        const { thisHanPtBySeat, totalAfter } =
            calcTotalsForAll(afterPlayers, uma, okaPt, returnPoint, totalsBefore);

        let html = "";

        html += `<div><strong>ã€ã“ã®æ‰‹ã®ç‚¹æ•°ã€‘</strong><br>`;
        if (winType === 'ron') {
            html += `ãƒ­ãƒ³ ${handInfo.label} â†’ ${handInfo.ron}ç‚¹`;
        } else {
            if (me.isParent) {
                html += `è¦ªãƒ„ãƒ¢ ${handInfo.label} â†’ ${handInfo.tsumoEach}ã‚ªãƒ¼ãƒ«`;
            } else {
                html += `å­ãƒ„ãƒ¢ ${handInfo.label} â†’ è¦ª ${handInfo.tsumoFromParent}ç‚¹ãƒ»å­ ${handInfo.tsumoFromChild}ç‚¹`;
            }
        }
        html += `</div><br>`;

        html += `<div><strong>ã€ã“ã®åŠè˜ã®ãƒã‚¤ãƒ³ãƒˆåæ”¯ã€‘</strong><br>`;
        for (let i = 0; i < 4; i++) {
            const sign = thisHanPtBySeat[i] >= 0 ? "+" : "";
            html += `${winds[i]}ï¼š${sign}${thisHanPtBySeat[i].toFixed(1)}pt`;
            if (i === mySeat) html += "ï¼ˆè‡ªåˆ†ï¼‰";
            html += "<br>";
        }
        html += `</div><br>`;

        html += `<div><strong>ã€çµ‚äº†æ™‚ãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆã€‘</strong><br>`;
        for (let i = 0; i < 4; i++) {
            const signB = totalsBefore[i] >= 0 ? "+" : "";
            const signA = totalAfter[i] >= 0 ? "+" : "";
            html += `${winds[i]}ï¼šé–‹å§‹ ${signB}${totalsBefore[i].toFixed(1)}pt â†’ çµ‚äº† ${signA}${totalAfter[i].toFixed(1)}pt`;
            if (i === mySeat) html += "ï¼ˆè‡ªåˆ†ï¼‰";
            html += "<br>";
        }
        html += `</div>`;

        const custom = document.getElementById('customResult');
        custom.style.display = "block";
        custom.innerHTML = html;
    }

    // --- é˜²å¾¡ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼šãƒˆãƒ¼ã‚¿ãƒ«é †ä½ãŒè½ã¡ã‚‹æ¡ä»¶ã‚’è¨ˆç®— ---
    function findTotalDropDirect(defender, attacker, players, pot, honba, uma, okaPt, returnPoint, totalsBefore, myTotalRankBefore) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, attacker.isParent).ron;
            const pb = scoreHand(b.han, b.fu, attacker.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, attacker.isParent);
            const afterPlayers = simulateDirectRon(attacker, defender, players, handInfo.ron, pot, honba);
            const { totalAfter } = calcTotalsForAll(afterPlayers, uma, okaPt, returnPoint, totalsBefore);
            const totalArr = [totalAfter[0], totalAfter[1], totalAfter[2], totalAfter[3]];
            const totalRankAfter = rankArray(totalArr).rankBySeat[defender.seat];

            if (totalRankAfter > myTotalRankBefore) {
                return {
                    score: handInfo.ron,
                    beforeRank: myTotalRankBefore,
                    afterRank: totalRankAfter,
                    text: `${attacker.name}ã« ${handInfo.label}ï¼ˆãƒ­ãƒ³ ${handInfo.ron}ç‚¹ï¼‰ã‚’ã‚¢ã‚¬ã‚‰ã‚Œã‚‹ã¨ã€ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ãŒ${myTotalRankBefore}ä½ã‹ã‚‰${totalRankAfter}ä½ã«è½ã¡ã¾ã™ã€‚`
                };
            }
        }
        return null;
    }

    function findTotalDropTsumo(defender, attacker, players, pot, honba, uma, okaPt, returnPoint, totalsBefore, myTotalRankBefore) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, attacker.isParent).ron;
            const pb = scoreHand(b.han, b.fu, attacker.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, attacker.isParent);
            const afterPlayers = simulateTsumoWithHand(attacker, players, handInfo, pot, honba);
            const { totalAfter } = calcTotalsForAll(afterPlayers, uma, okaPt, returnPoint, totalsBefore);
            const totalArr = [totalAfter[0], totalAfter[1], totalAfter[2], totalAfter[3]];
            const totalRankAfter = rankArray(totalArr).rankBySeat[defender.seat];

            if (totalRankAfter > myTotalRankBefore) {
                return {
                    score: handInfo.ron,
                    beforeRank: myTotalRankBefore,
                    afterRank: totalRankAfter,
                    text: `${attacker.name}ã« ${handInfo.label}ï¼ˆ${getTsumoDesc(handInfo, attacker.isParent)}ï¼‰ã‚’ãƒ„ãƒ¢ã‚‰ã‚Œã‚‹ã¨ã€ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ãŒ${myTotalRankBefore}ä½ã‹ã‚‰${totalRankAfter}ä½ã«è½ã¡ã¾ã™ã€‚`
                };
            }
        }
        return null;
    }

    function findTotalDropSide(defender, attacker, players, pot, honba, uma, okaPt, returnPoint, totalsBefore, myTotalRankBefore) {
        const sortedCand = [...candidateHands].sort((a, b) => {
            const pa = scoreHand(a.han, a.fu, attacker.isParent).ron;
            const pb = scoreHand(b.han, b.fu, attacker.isParent).ron;
            return pa - pb;
        });

        for (const cand of sortedCand) {
            const handInfo = scoreHand(cand.han, cand.fu, attacker.isParent);
            const afterPlayers = simulateSideRon(attacker, defender, players, handInfo.ron, pot, honba);
            const { totalAfter } = calcTotalsForAll(afterPlayers, uma, okaPt, returnPoint, totalsBefore);
            const totalArr = [totalAfter[0], totalAfter[1], totalAfter[2], totalAfter[3]];
            const totalRankAfter = rankArray(totalArr).rankBySeat[defender.seat];

            if (totalRankAfter > myTotalRankBefore) {
                return {
                    score: handInfo.ron,
                    beforeRank: myTotalRankBefore,
                    afterRank: totalRankAfter,
                    text: `${attacker.name}ãŒä»–å®¶ã‹ã‚‰ ${handInfo.label}ï¼ˆãƒ­ãƒ³ ${handInfo.ron}ç‚¹ï¼‰ã§ã‚¢ã‚¬ã‚‹ã¨ã€ãã®ç‚¹æ£’ç§»å‹•ã«ã‚ˆã‚Šãƒˆãƒ¼ã‚¿ãƒ«é †ä½ãŒ${myTotalRankBefore}ä½ã‹ã‚‰${totalRankAfter}ä½ã«è½ã¡ã¾ã™ã€‚`
                };
            }
        }
        return null;
    }

    function calculateDefense(players, scoresBefore, totalsBefore, me, pot, honba, uma, okaPt, returnPoint, myTotalRank0) {
        const resultsDiv = document.getElementById('resultArea');
        resultsDiv.innerHTML = "";

        const mySeat = me.seat;

        if (myTotalRank0 === 4) {
            resultsDiv.innerHTML =
                "<div style='text-align:center; padding:20px; font-weight:bold; color:#c0392b;'>" +
                "ç¾åœ¨ãƒˆãƒ¼ã‚¿ãƒ«ãƒ©ã‚¹ã®ãŸã‚ã€ã“ã‚Œä»¥ä¸Šé †ä½ãŒè½ã¡ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚<br>æ¬¡ã®åŠè˜ä»¥é™ã§ã®å·»ãè¿”ã—ã‚’æ„è­˜ã—ã¾ã—ã‚‡ã†ã€‚" +
                "</div>";
            return;
        }

        // è‡ªåˆ†ã‚ˆã‚Šãƒˆãƒ¼ã‚¿ãƒ«ãŒä¸‹ã®ç›¸æ‰‹ã ã‘ã‚’ã€Œè¿½ã„ä¸Šã’ã¦ãã‚‹è„…å¨ã€ã¨ã—ã¦è¦‹ã‚‹
        const threats = players.filter(p => p.seat !== mySeat && totalsBefore[p.seat] <= totalsBefore[mySeat]);
        threats.sort((a, b) => (totalsBefore[b.seat] - totalsBefore[a.seat])); // è¿‘ã„ç›¸æ‰‹ã‹ã‚‰

        if (threats.length === 0) {
            resultsDiv.innerHTML =
                "<div style='text-align:center; padding:20px; font-weight:bold; color:#27ae60;'>" +
                "ç¾åœ¨ãƒˆãƒ¼ã‚¿ãƒ«ã§ä¸Šä½ã®ç›¸æ‰‹ã—ã‹ãŠã‚‰ãšã€ã“ã®å±€ã§ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ãŒè½ã¡ã‚‹å¯èƒ½æ€§ã¯ã»ã¨ã‚“ã©ã‚ã‚Šã¾ã›ã‚“ã€‚" +
                "</div>";
            return;
        }

        let anyCard = false;

        threats.forEach(attacker => {
            const beforeDiff = totalsBefore[mySeat] - totalsBefore[attacker.seat];

            const directRes = findTotalDropDirect(me, attacker, players, pot, honba, uma, okaPt, returnPoint, totalsBefore, myTotalRank0);
            const tsumoRes  = findTotalDropTsumo(me, attacker, players, pot, honba, uma, okaPt, returnPoint, totalsBefore, myTotalRank0);
            const sideRes   = findTotalDropSide(me, attacker, players, pot, honba, uma, okaPt, returnPoint, totalsBefore, myTotalRank0);

            if (!directRes && !tsumoRes && !sideRes) {
                return; // ã“ã®ç›¸æ‰‹ã§ã¯é †ä½è½ã¡ã¯ç™ºç”Ÿã—ãªã„
            }

            anyCard = true;

            const difficulty = classifyDifficulty([directRes, tsumoRes, sideRes]);

            let cardClass = "target-card";
            let highlightIcon = "";
            let collapsed = false;

            if (difficulty === "easy") {
                cardClass += " target-card-easy";
                highlightIcon = '<span class="chance-badge">è¦è­¦æˆ’ï¼</span>';
            } else if (difficulty === "hard") {
                cardClass += " target-card-hard";
                collapsed = true;
            }

            const cardId = `cardBody_${cardCounter++}`;
            const bodyStyle = collapsed ? " style='display:none;'" : "";
            const toggleLabel = collapsed ? "è©³ç´°ã‚’è¡¨ç¤º" : "è©³ç´°ã‚’éš ã™";

            const leadText = beforeDiff >= 0
                ? `ç¾åœ¨ã®ãƒˆãƒ¼ã‚¿ãƒ«å·®ï¼šè‡ªåˆ†ãŒ ${beforeDiff.toFixed(1)}pt ãƒªãƒ¼ãƒ‰`
                : `ç¾åœ¨ã®ãƒˆãƒ¼ã‚¿ãƒ«å·®ï¼šè‡ªåˆ†ãŒ ${Math.abs(beforeDiff).toFixed(1)}pt ãƒ“ãƒã‚¤ãƒ³ãƒ‰`;

            let html = `<div class="${cardClass}">`;
            html += `<div class="target-header">
                        <span>${highlightIcon}è­¦æˆ’å¯¾è±¡: ${attacker.name}</span>
                        <div class="target-header-right">
                            <span>${leadText}</span>
                            <button type="button" class="card-toggle-btn" onclick="toggleCardBody('${cardId}', this)">${toggleLabel}</button>
                        </div>
                     </div>`;
            html += `<div id="${cardId}"${bodyStyle}>`;

            html += makeDefenseRow("è‡ªåˆ†ã‹ã‚‰ç›´æ’ƒã•ã‚ŒãŸå ´åˆ", directRes);
            html += makeDefenseRow("ãƒ„ãƒ¢ã‚‰ã‚ŒãŸå ´åˆ", tsumoRes);
            html += makeDefenseRow("è„‡ã‹ã‚‰å‡ºã‚ãŒã‚Šã—ãŸå ´åˆ", sideRes);

            html += `</div></div>`;
            resultsDiv.innerHTML += html;
        });

        if (!anyCard) {
            resultsDiv.innerHTML =
                "<div style='text-align:center; padding:20px; font-weight:bold; color:#27ae60;'>" +
                "ã“ã®å±€é¢ã§ã¯ã€ã„ãšã‚Œã®ç›¸æ‰‹ã«ã‚¢ã‚¬ã‚‰ã‚Œã¦ã‚‚ãƒˆãƒ¼ã‚¿ãƒ«é †ä½ãŒè½ã¡ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆå®‰å…¨åœã§ã™ï¼‰ã€‚" +
                "</div>";
        }
    }

    window.addEventListener('load', () => {
        updateStatusSummary();
        updateSimWinType();
    });
</script>
</body>
</html>
